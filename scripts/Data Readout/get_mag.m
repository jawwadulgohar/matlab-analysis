function [out, points, spans, subset] = get_mag(data, len, polyorder, start, asym, frac, num_win, sr)
% Function for getting the magnetization curve as a function of time from an
% experiment consisting of a train of 180s.
%
% Required inputs:
% data      Either a data matrix or (preferably) a scalar of the type
%           generated by ReadTDMExperiment
% len       Length of the "window" from which you want to sample (in ms)
%
% Optional inputs: 
% polyorder Polynomial correction order. Default is -1 (no subtraction)
% start     Offset, default 0
% asym      Asymmetry between the offsets within the windows, default 0.5
% frac      Fraction (0->1) of the window to sample, default 0.5
% num_win   Number of "windows" to get out of the full set. Default is all
% sr        Sampling rate. Optional only if data is a struct. If data is a
%           struct, pass 'adata' to this to use average data.
%
% Pass -1 to any of these to use the defaults.
%
% Outputs:
% out       an output matrix with size(out, 1) = num_windows-1;
% points    an output matrix of size(points, 1) = num_windows;
% spans     a vector the size of the input vectors indicating where data
%           were sampled from
%
% All other dimensions come from the scalar
%
%   Illustration of "start", "len" and "window", all in ms. Sample is taken
%   in the |__| regions.
%
%    ______        _|__|_        _|__|_
%   |      |      |      |      |      |
%   |      |      |      |      |      |
%   |      |_|__|_|      |_|__|_|      |
%   start -->|    |< len>|  <>
%                            ^-window
%
% Usage:
% [out, points, spans] = get_mag(data, len, polyorder, start, asym, frac, num_win, sr);

if(~exist('data', 'var'))
    error('Must supply data!');
end

if(~exist('len', 'var'))
   error('Must supply a length of the subset.');
end

% Passing negative values to any of these will use defaults
if(~exist('start', 'var'))
    start = -1;
end

if(~exist('asym', 'var'))
    asym = -1;
end

if(~exist('frac', 'var'))
    frac = -1;
end

if(~exist('num_win', 'var'))
    num_win = -1;
end

% Get the subsets
if(~exist('sr', 'var'))
    [subs, spans, subset] = get_subset(data, len, start, asym, frac, num_win);
else
    [subs, spans, subset] = get_subset(data, len, start, asym, frac, num_win, sr);
end

% Do the polynomial fit if requested.
 if(exist('polyorder', 'var') && polyorder >= 0)
     subs = sub_poly(subs, polyorder, 1);
 end

% Now average the output and remove the trailing singleton
% Don't want to use squeeze in case there are 'placeholder' singletons
% elsehwere.
subs = mean(subs, 1);
s = num2cell(size(subs));
subs = reshape(subs, s{2:end});
s = s(2:end);
s{1} = s{1}-1;

% Finally we can make this thing the output.
points = subs;
out = zeros(s{:});
out(1:2:end, :) = points(1:2:end-1, :) - points(2:2:end, :);
out(2:2:end, :) = points(3:2:end, :) - points(2:2:end, :);